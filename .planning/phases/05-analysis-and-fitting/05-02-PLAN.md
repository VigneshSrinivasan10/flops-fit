---
phase: 05-analysis-and-fitting
plan: "02"
type: tdd
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/flops_fit/analyzer.py
  - tests/test_analyzer.py
autonomous: true

must_haves:
  truths:
    - "ScalingAnalysis.chinchilla_table() returns a markdown table with Compute Budget, Optimal N, Optimal D, D/N Ratio, and Predicted Loss columns"
    - "chinchilla_table() accepts optional compute_budgets list; defaults to 9 log-spaced budgets from 1e18 to 1e22"
    - "predict_optimal_size() incorporates l_inf from l_opt_fit when predicting expected_loss"
    - "Chinchilla table predictions use all three fitted power laws (n_opt_fit, d_opt_fit, l_opt_fit)"
  artifacts:
    - path: "src/flops_fit/analyzer.py"
      provides: "ScalingAnalysis.chinchilla_table() method and updated predict_optimal_size()"
      contains: "chinchilla_table"
    - path: "tests/test_analyzer.py"
      provides: "TDD tests for chinchilla_table() and end-to-end prediction with l_inf"
      exports: ["TestChinchillaTable"]
  key_links:
    - from: "ScalingAnalysis.chinchilla_table()"
      to: "ScalingAnalysis.predict_optimal_size()"
      via: "calls predict_optimal_size(budget) for each budget in compute_budgets list"
      pattern: "predict_optimal_size"
    - from: "predict_optimal_size()"
      to: "l_opt_fit.predict()"
      via: "l_opt_fit.predict() now uses l_inf in PowerLawFit.predict()"
      pattern: "l_opt_fit.predict"
---

<objective>
Add chinchilla_table() to ScalingAnalysis and ensure predict_optimal_size() correctly uses the l_inf term from the refactored power law fits.

Purpose: Phase 5 success criterion 3 requires Chinchilla table output. The table consolidates all three power law fits into a human-readable summary of optimal N, D, and predicted loss for a range of compute budgets. predict_optimal_size() must propagate the l_inf term through to expected_loss so predictions are accurate.

Output: chinchilla_table() method on ScalingAnalysis; updated predict_optimal_size() with l_inf-aware loss prediction; tests for both via TDD.
</objective>

<execution_context>
@/home/viggie/.claude/get-shit-done/workflows/execute-plan.md
@/home/viggie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/05-analysis-and-fitting/05-RESEARCH.md
@src/flops_fit/analyzer.py
@tests/test_analyzer.py
@.planning/phases/05-analysis-and-fitting/05-01-SUMMARY.md
</context>

<feature>
  <name>Chinchilla table output and l_inf-aware loss prediction</name>
  <files>src/flops_fit/analyzer.py, tests/test_analyzer.py</files>
  <behavior>
    predict_optimal_size() with l_inf propagation:
    - l_fit = PowerLawFit(name="L_opt", coefficient_k=2.0, exponent_a=0.5, r_squared=0.99, l_inf=1.0)
    - analysis = ScalingAnalysis(n_opt_fit=n_fit, d_opt_fit=d_fit, l_opt_fit=l_fit, ...)
    - result = analysis.predict_optimal_size(4.0)
    - result["expected_loss"] == 1.0 + 2.0 * sqrt(4.0) = 5.0
    (Because PowerLawFit.predict() handles l_inf — no change needed here; this is a regression check)

    chinchilla_table() with default budgets:
    - analysis.chinchilla_table() returns a string
    - String contains "| Compute Budget |" header line
    - String contains 9 data rows (1e18 through 1e22, 9 log-spaced points)
    - Each row has 5 fields separated by " | "

    chinchilla_table() with custom budgets:
    - analysis.chinchilla_table(compute_budgets=[1e18, 1e20]) returns string with 2 data rows
    - Row for 1e18 shows correct values from predict_optimal_size(1e18)
    - Row for 1e20 shows correct values from predict_optimal_size(1e20)

    chinchilla_table() formatting:
    - Compute budget formatted as scientific notation (e.g., "1.00e+18")
    - optimal_params formatted as integer with comma separator (e.g., "1,000,000")
    - optimal_tokens formatted as integer with comma separator
    - tokens_per_param formatted as float with 1 decimal (e.g., "20.0")
    - expected_loss formatted as float with 4 decimals (e.g., "3.2400")

    end-to-end: planner -> trainer (mock) -> analyzer -> chinchilla_table():
    - With 5 compute budgets and 7 model sizes:
        analysis = analyzer.analyze()
        table = analysis.chinchilla_table()
        assert "Compute Budget" in table
        assert "Optimal N" in table
        assert len(table.split("\n")) >= 11  # header + separator + 9 data rows
  </behavior>
  <implementation>
    Step 1: Verify predict_optimal_size() works correctly with l_inf. Since PowerLawFit.predict() was updated in Plan 01 to add l_inf, predict_optimal_size() calls self.l_opt_fit.predict() and the l_inf is already incorporated. No code change needed — but write a regression test to confirm.

    Step 2: Add chinchilla_table() method to ScalingAnalysis class:

    def chinchilla_table(
        self,
        compute_budgets: list[float] | None = None,
    ) -> str:
        """
        Generate Chinchilla-style table of optimal configurations.

        Calls predict_optimal_size() for each compute budget and formats
        the results as a markdown table showing optimal N, D, D/N ratio,
        and predicted loss.

        Args:
            compute_budgets: List of FLOPs values to tabulate. If None,
                uses 9 logarithmically-spaced budgets from 1e18 to 1e22.

        Returns:
            Markdown-formatted table string.
        """
        if compute_budgets is None:
            compute_budgets = list(np.logspace(18, 22, 9))

        header = (
            "| Compute Budget | Optimal N | Optimal D | D/N Ratio | Predicted Loss |\n"
            "|---|---|---|---|---|"
        )

        rows = [header]
        for budget in compute_budgets:
            pred = self.predict_optimal_size(budget)
            n = pred["optimal_params"]
            d = pred["optimal_tokens"]
            ratio = pred["tokens_per_param"]
            loss = pred["expected_loss"]
            row = (
                f"| {budget:.2e} "
                f"| {n:,} "
                f"| {d:,} "
                f"| {ratio:.1f} "
                f"| {loss:.4f} |"
            )
            rows.append(row)

        return "\n".join(rows)

    Note: numpy is already imported in the file (import numpy as np). No new imports needed.

    After implementing, run tests:
    cd /home/viggie/Projects/flops-fit && uv run pytest tests/test_analyzer.py -x --tb=short 2>&1 | tail -20

    Commit: feat(05-02): add chinchilla_table() to ScalingAnalysis
  </implementation>
</feature>

<tasks>

<task type="tdd">
  <name>Task 1: RED - Write failing tests for chinchilla_table() and predict_optimal_size() l_inf propagation</name>
  <files>tests/test_analyzer.py</files>
  <action>
    Add a new test class TestChinchillaTable after the existing TestScalingAnalysis class. Also add a test to TestScalingAnalysis for predict_optimal_size() with l_inf. Do NOT modify existing tests.

    In TestScalingAnalysis, add:

    test_predict_optimal_size_uses_l_inf_for_loss:
      - l_fit = PowerLawFit(name="L_opt", coefficient_k=2.0, exponent_a=0.5, r_squared=0.99, l_inf=1.0)
      - n_fit = PowerLawFit(name="N_opt", coefficient_k=1.0, exponent_a=0.5, r_squared=0.99)
      - d_fit = PowerLawFit(name="D_opt", coefficient_k=1.0, exponent_a=0.5, r_squared=0.99)
      - analysis = ScalingAnalysis(n_opt_fit=n_fit, d_opt_fit=d_fit, l_opt_fit=l_fit, optimal_points=[], optimal_ratio=1.0)
      - result = analysis.predict_optimal_size(4.0)
      # l_inf=1.0 + k=2.0 * 4.0^0.5 = 1.0 + 4.0 = 5.0
      - assert result["expected_loss"] == pytest.approx(5.0)

    TestChinchillaTable class:

    test_chinchilla_table_returns_string:
      - n_fit = PowerLawFit(name="N_opt", coefficient_k=1e6, exponent_a=0.5, r_squared=0.99)
      - d_fit = PowerLawFit(name="D_opt", coefficient_k=2e7, exponent_a=0.5, r_squared=0.99)
      - l_fit = PowerLawFit(name="L_opt", coefficient_k=0.1, exponent_a=-0.05, r_squared=0.99, l_inf=1.5)
      - analysis = ScalingAnalysis(n_opt_fit=n_fit, d_opt_fit=d_fit, l_opt_fit=l_fit, optimal_points=[], optimal_ratio=20.0)
      - table = analysis.chinchilla_table()
      - assert isinstance(table, str)

    test_chinchilla_table_default_has_9_rows:
      - (same analysis setup as above)
      - table = analysis.chinchilla_table()
      - lines = table.strip().split("\n")
      # header + separator + 9 data rows = 11 lines
      - assert len(lines) == 11

    test_chinchilla_table_custom_budgets:
      - (same analysis setup as above)
      - table = analysis.chinchilla_table(compute_budgets=[1e18, 1e20, 1e22])
      - lines = table.strip().split("\n")
      # header + separator + 3 data rows = 5 lines
      - assert len(lines) == 5

    test_chinchilla_table_contains_header:
      - (same analysis setup as above)
      - table = analysis.chinchilla_table()
      - assert "Compute Budget" in table
      - assert "Optimal N" in table
      - assert "Optimal D" in table
      - assert "Predicted Loss" in table

    test_chinchilla_table_values_from_predict:
      - (same analysis setup as above)
      - table = analysis.chinchilla_table(compute_budgets=[1e20])
      - pred = analysis.predict_optimal_size(1e20)
      # Expected loss should appear in table (formatted to 4 decimals)
      - assert f"{pred['expected_loss']:.4f}" in table

    test_chinchilla_table_end_to_end(tmp_path):
      - (same planner/trainer/analyzer setup as test_analyze_produces_valid_fits)
      - Use 5 compute budgets 1e17 to 1e21, 7 model sizes
      - np.random.seed(42); run mock training; run analyzer.analyze()
      - table = analysis.chinchilla_table(compute_budgets=[1e18, 1e19, 1e20])
      - assert isinstance(table, str)
      - assert "Compute Budget" in table
      - assert len(table.split("\n")) >= 5

    Run tests: cd /home/viggie/Projects/flops-fit && uv run pytest tests/test_analyzer.py::TestChinchillaTable tests/test_analyzer.py::TestScalingAnalysis::test_predict_optimal_size_uses_l_inf_for_loss -x --tb=short 2>&1 | head -30
    These MUST fail (RED). Commit: test(05-02): add failing tests for chinchilla_table() and l_inf prediction
  </action>
  <verify>cd /home/viggie/Projects/flops-fit && uv run pytest tests/test_analyzer.py::TestChinchillaTable tests/test_analyzer.py::TestScalingAnalysis::test_predict_optimal_size_uses_l_inf_for_loss -x --tb=short 2>&1 | grep -E "(FAILED|ERROR|AttributeError)" | head -10</verify>
  <done>All new tests fail with AttributeError (chinchilla_table method does not exist) or AssertionError (RED state confirmed). Existing tests still pass.</done>
</task>

<task type="tdd">
  <name>Task 2: GREEN - Implement chinchilla_table() in ScalingAnalysis</name>
  <files>src/flops_fit/analyzer.py</files>
  <action>
    Add the chinchilla_table() method to the ScalingAnalysis class in src/flops_fit/analyzer.py.

    Place the method after predict_optimal_size() and before to_dict().

    Implementation:

    def chinchilla_table(
        self,
        compute_budgets: list[float] | None = None,
    ) -> str:
        """
        Generate Chinchilla-style table of optimal configurations.

        For each compute budget, calls predict_optimal_size() and formats
        the result as a markdown table row showing:
        - Compute budget (scientific notation)
        - Optimal model size N (integer, comma-separated)
        - Optimal tokens D (integer, comma-separated)
        - D/N ratio (1 decimal float)
        - Predicted loss (4 decimal float)

        Args:
            compute_budgets: List of FLOPs values to tabulate. If None,
                uses 9 log-spaced budgets from 1e18 to 1e22.

        Returns:
            Markdown-formatted table string (header + separator + data rows).
        """
        if compute_budgets is None:
            compute_budgets = list(np.logspace(18, 22, 9))

        header = (
            "| Compute Budget | Optimal N | Optimal D | D/N Ratio | Predicted Loss |\n"
            "|---|---|---|---|---|"
        )

        rows = [header]
        for budget in compute_budgets:
            pred = self.predict_optimal_size(budget)
            n = pred["optimal_params"]
            d = pred["optimal_tokens"]
            ratio = pred["tokens_per_param"]
            loss = pred["expected_loss"]
            row = (
                f"| {budget:.2e} "
                f"| {n:,} "
                f"| {d:,} "
                f"| {ratio:.1f} "
                f"| {loss:.4f} |"
            )
            rows.append(row)

        return "\n".join(rows)

    Note: numpy (np) is already imported. No new imports needed.

    After adding the method, run all tests:
    cd /home/viggie/Projects/flops-fit && uv run pytest tests/test_analyzer.py -x --tb=short 2>&1 | tail -20

    If test_predict_optimal_size_uses_l_inf_for_loss fails: the l_inf propagation already works via PowerLawFit.predict() from Plan 01. If Plan 01 implemented predict() correctly, no code change is needed. If the test somehow still fails, check PowerLawFit.predict() includes the l_inf addition.

    Run full suite to check for regressions:
    cd /home/viggie/Projects/flops-fit && uv run pytest --tb=short 2>&1 | tail -10

    Commit: feat(05-02): add chinchilla_table() to ScalingAnalysis
  </action>
  <verify>cd /home/viggie/Projects/flops-fit && uv run pytest tests/test_analyzer.py -x --tb=short 2>&1 | tail -10</verify>
  <done>All tests in tests/test_analyzer.py pass, including TestChinchillaTable (6 tests) and test_predict_optimal_size_uses_l_inf_for_loss. analysis.chinchilla_table() returns a markdown table with correct structure and values. Full test suite passes with no regressions.</done>
</task>

</tasks>

<verification>
Run full test suite to confirm no regressions:
cd /home/viggie/Projects/flops-fit && uv run pytest --tb=short 2>&1 | tail -15

Confirm chinchilla_table() method exists and produces valid output:
cd /home/viggie/Projects/flops-fit && uv run python -c "
from flops_fit.analyzer import ScalingAnalysis, PowerLawFit
import numpy as np
n = PowerLawFit('N_opt', 1e6, 0.5, 0.99)
d = PowerLawFit('D_opt', 2e7, 0.5, 0.99)
l = PowerLawFit('L_opt', 0.1, -0.05, 0.99, l_inf=1.5)
a = ScalingAnalysis(n, d, l, [], 20.0)
print(a.chinchilla_table(compute_budgets=[1e18, 1e20]))
"

Verify ANLZ-01, ANLZ-02, ANLZ-03 success criteria:
- ANLZ-01 (power law fits with R²): test_analyze_produces_valid_fits passes with r_squared > 0
- ANLZ-02 (outlier detection): TestOutlierDetection tests pass; outliers excluded improve R²
- ANLZ-03 (chinchilla table): analysis.chinchilla_table() returns formatted markdown table
</verification>

<success_criteria>
- All existing tests pass (no regressions from Phase 4's 144 tests)
- TestChinchillaTable: 6 tests pass
- test_predict_optimal_size_uses_l_inf_for_loss passes (l_inf propagated to expected_loss)
- chinchilla_table() returns string with "Compute Budget", "Optimal N", "Optimal D", "Predicted Loss" in header
- chinchilla_table() default produces 11 lines (header + separator + 9 data rows)
- chinchilla_table() accepts custom compute_budgets list
- Phase 5 success criteria fully met: ANLZ-01, ANLZ-02, ANLZ-03 all satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-analysis-and-fitting/05-02-SUMMARY.md`
</output>
